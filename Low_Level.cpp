#include "TempBasedStegonography.h"

using namespace stego;

ullong stego::Low_Level::readTemp(uchar ** data) {
	std::ifstream in("temp.dat" , std::ios::in | std::ios::binary | std::ios::ate);
	ullong size = 0;
	if (!in.is_open()) return 0;

	in.seekg(0, std::ios::end);
	size = in.tellg();
	in.seekg(0, std::ios::beg);
	*data = new uchar[size];
	in.read((char*)*data, size);
	in.close();
	return size;
}



void stego::Low_Level::writeTemp(uchar ** data) {
	std::ofstream out("temp.dat", std::ios::binary);
	int width = 0;
	for (int i = 0; i < 4; i++) {
		width |= (((int)*((*data)++)) << ((3 - i) * 8));
	}
	int height = 0;
	for (int i = 0; i < 4; i++) {
		height |= (((int)*((*data)++)) << ((3 - i) * 8));
	}
	ullong containerSize = (uint)width*height * 3;

	(*data) -= 8;
	out.write((char*)*data, (containerSize+8));
	out.close();
}

ullong stego::Low_Level::takeFileBufferFromJpgStructure(std::string imagename, uchar ** data) {

	std::ifstream in(imagename, std::ios::in | std::ios::binary);
	in.seekg(0, std::ios::end);
	ullong size = in.tellg();
	in.seekg(0, std::ios::beg);

	uchar last, now;
	in >> last;
	in >> now;
	ullong i = 0;
	ullong dataSize = 0;
	bool readFlag = false;
	for (; !in.eof(); last = now, in >> now) {
		if (last == 0xff && now == 0xc7) {
			if (!readFlag) {
				readFlag = true;
				dataSize = 0;
				uchar buffer;
				for (int i = 0; i < 8; i++) {
					in >> buffer;
					dataSize *= 256;
					dataSize += ( buffer) ;
				}
				*data = new uchar[dataSize];
				in.read((char*)*data, dataSize);
				break;

			} 
		}
		i++;
	}
	
	in.close();
	return dataSize;
}

int stego::Low_Level::hideFileBufferInJpgStructure(std::string imagename, uchar ** data, ullong size) {
	std::ifstream in(imagename, std::ios::binary);

	uchar last, now;
	in >> last;
	in >> now;
	for (; !in.eof(); last = now, in >> now) {
		if (last == 0xff && now == 0xc7) {
			return 0;
		}
	}

	in.close();

	std::ofstream out(imagename, std::ios::binary | std::ios_base::app);
	if (!out.is_open()) {
		return 0;
	}

	uchar buffer = 0xff;
	out.write((char*)&buffer, 1);
	buffer = 0xc7;
	out.write((char*)&buffer, 1);


	for (int i = 0; i < 8; i++) {
		buffer = (size >> ((7 - i) * 8)) & 0xff;
		out.write((char*)&buffer, 1);
	}
	out.write((char *)(*data), size);

	out.close();
	return size;
}

uchar Low_Level::read8LSB(uchar* data) {
	uchar secret = 0;
	for (int i = 0; i < 8; i++) {
		secret |= (data[i] & 0x01) << (7 - i);
	}
	return secret;
}

/*
secret and container are the char arrays that were gotten from readFile and readImage
ONLY in this case the function works  properly
*/
int Low_Level::keylessLSB(uchar** container, uchar** secret) {

	uchar formatSize = *(*secret)++;
	*secret += formatSize;
	uint filesize = 0;
	for (int i = 0; i < 8; i++) {
		filesize |= (((uint)*((*secret)++)) << ((7 - i) * 8));
	}
	uint secretSize = 1 + 8 + filesize + formatSize;

	//We determine the size of the container to thech the possibility of hiding a secret in it
	int width = 0;
	for (int i = 0; i < 4; i++) {
		width |= (((int)*((*container)++)) << ((3 - i) * 8));
	}
	int height = 0;
	for (int i = 0; i < 4; i++) {
		height |= (((int)*((*container)++)) << ((3 - i) * 8));
	}
	ullong containerSize = (uint)width*height * 3;

	// secret's pointer is reseted to the position before header, because header should also be hided
	// container's is not, because we dont hide in the bits that store the size information
	*secret -= 1 + 8 + formatSize;



	//We determine the size of the container to thech the possibility of hiding a secret in it
	if ((secretSize * 8) > containerSize) 
		return -1;

	for (uint i = 0; i < secretSize; i++) {
		for (int j = 0; j < 8; j++) {
			*(*container)++ = (**container & 0xfe) | (0x01 & (**secret >> (7 - j)));
		}
		(*secret)++;
	}
	*secret -= secretSize;
	*container -= (secretSize * 8 + 8);

	int a = 0;
	return 0;
}

/*
container is a char array gotten fron imageReader, where image contained a secret in a format returned from readFile
secret is a pointer to  an empty char array
ONLY in this case the function works  properly
*/
ullong Low_Level::de_keylessLSB(uchar** container, uchar** secret) {

	int carate = 0;
	carate += 8; //avoid reading size information
	uchar filenameSize = read8LSB(&(*container)[carate]);
	carate += 8;

	std::string filename;

	for (int i = 0; i < filenameSize; i++) {
		uchar digit = read8LSB(&(*container)[carate]);

		filename += read8LSB(&(*container)[carate]);
		carate += 8;
	}

	ullong fileSize = 0;
	
	for (int i = 0; i < 8; i++) {
		fileSize |= (uint)(read8LSB(&(*container)[carate]) << ((7 - i) * 8));
		carate += 8;
	}

	if (fileSize > 1E9) return 0;
		*secret = new uchar[1 + filenameSize + 8 + fileSize];
	
	*(*secret)++ = filenameSize;
	
	for (int i = 0; i < filenameSize; i++) {
		*(*secret)++ = filename.at(i);
	}
	
	for (int i = 0; i < 8; i++) {
		*(*secret)++ = (uchar)((fileSize >> (8 * (7 - i))));
	}
	
	for (uint i = 0; i < fileSize; i++) {
		*(*secret)++ = read8LSB(&(*container)[carate]);
		carate += 8;
	}

	*secret -= (1 + filenameSize + 8 + fileSize);
	return (1 + filenameSize + 8 + fileSize);
}










//HERE GOES CRYPTO

void crypto::Low_Level::encryptAES(uchar(&input)[16], uchar(&key)[32]) {
	uchar dataMatrix[4][4];
	uchar w_key[240];
	keyExpantion(key, w_key);
	//std::cout << rijndael[2][2] << "____";


	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 4; c++) {
			dataMatrix[r][c] = input[r + c * 4];
		}
	}
	addRoundKey(w_key, dataMatrix, 0);
	for (int i = 1; i < 14; i++) {
		subData(dataMatrix);
		shiftRows(dataMatrix);
		mixCols(dataMatrix);
		addRoundKey(w_key, dataMatrix, i);
	}	
	subData(dataMatrix);
	shiftRows(dataMatrix);
	addRoundKey(w_key, dataMatrix, 14);
	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 4; c++) {
			input[r + c * 4] = dataMatrix[r][c];
		}
	}
}

void crypto::Low_Level::decryptAES(uchar(&input)[16], uchar(&key)[32]) {
	uchar dataMatrix[4][4];
	uchar w_key[240];
	keyExpantion(key, w_key);

	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 4; c++) {
			dataMatrix[r][c] = input[r + c * 4];
		}
	}


	addRoundKey(w_key, dataMatrix, 14);

	for (int i = 1; i < 14; i++) {

		invShiftRows(dataMatrix);
		invSubData(dataMatrix);
		addRoundKey(w_key, dataMatrix, 14 - i);
		invMixCols(dataMatrix);

	}

	invSubData(dataMatrix);
	invShiftRows(dataMatrix);
	addRoundKey(w_key, dataMatrix, 0);

	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 4; c++) {
			input[r + c * 4] = dataMatrix[r][c];
		}
	}
}

void crypto::Low_Level::keyScheduleCore(uchar(&data)[4], int i) {
	leftRotation(data);
	subWord(data);

	data[0] = data[0] ^ rcon[i];

}

void crypto::Low_Level::subWord(uchar(&data)[4]) {
	for (int j = 0; j < 4; j++) {
		data[j] = s_box[data[j]];
	}
}

void crypto::Low_Level::invShiftRows(uchar(&data)[4][4]) {
	uchar result[4];
	for (int i = 1; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			result[j] = data[i][(j - i + 4) % 4];
		}
		for (int j = 0; j < 4; j++) {
			data[i][j] = result[j];
		}
	}
}

void crypto::Low_Level::invMixCols(uchar(&data)[4][4]) {
	multiply4(inverce_rijndael, data);
}

void crypto::Low_Level::invSubData(uchar(&data)[4][4]) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			data[i][j] = inverce_s_box[data[i][j]];
		}
	}
}

void crypto::Low_Level::leftRotation(uchar(&data)[4]) {
	for (int k = 0; k < 3; k++){
		std::swap(data[k], data[k + 1]);
	}
}

void crypto::Low_Level::shiftRows(uchar(&data)[4][4]) {
	uchar result[4];
	for (int i = 1; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			result[j] = data[i][(j + i) % 4];
		}
		for (int j = 0; j < 4; j++) {
			data[i][j] = result[j];
		}
	}
}

void crypto::Low_Level::mixCols(uchar(&data)[4][4]) {
	multiply4(rijndael, data);
}

void crypto::Low_Level::subData(uchar(&data)[4][4]) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			data[i][j] = s_box[data[i][j]];
		}
	}
}

void crypto::Low_Level::addRoundKey(uchar(&key)[240], uchar(&data)[4][4], int round) {
	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 4; c++) {
			data[r][c] ^= key[round*16 + r+c*4];
		}
	}
}

void crypto::Low_Level::multiply4(uchar(&pred)[4][4], uchar(&data)[4][4]) {
	uchar result[4][4];
	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 4; c++) {
			uchar sum = 0;
			for (int i = 0; i < 4; i++) {
				sum ^= multiplyInG256(pred[r][i], data[i][c]) ;
			}
			result[r][c] = sum;
		}
	}
	for (int r = 0; r < 4; r++) {
		for (int c = 0; c < 4; c++) {
			data[r][c] = result[r][c];
		}
	}
}

void crypto::Low_Level::keyExpantion(uchar(&key)[32], uchar(&w_key)[240])
{
	for (int k = 0; k < 32 ; k++) {
		w_key[k] = key[k];
	}
	int I = 1;
	for (int k = 32; k < 240; k+=4) {
		uchar t[4]{ 
			w_key[k - 4], 
			w_key[k - 3],
			w_key[k - 2],
			w_key[k - 1] 
		};
		if ((k/4) % 8 == 0) {
			keyScheduleCore(t, I);
			I++;
		} else if ((k/4) % 8 == 4) {
			subWord(t);
		}
		w_key[k  ] = t[0] ^ w_key[k - 32];
		w_key[k+1] = t[1] ^ w_key[k - 32 + 1];
		w_key[k+2] = t[2] ^ w_key[k - 32 + 2];
		w_key[k+3] = t[3] ^ w_key[k - 32 + 3];
	}
}

uchar crypto::Low_Level::multiplyInG256(uchar a, uchar b) {
	uchar p = 0; /* the product of the multiplication */
	while (b) {
		if (b & 1) /* if b is odd, then add the corresponding a to p (final product = sum of all a's corresponding to odd b's) */
			p ^= a; /* since we're in GF(2^m), addition is an XOR */

		if (a & 0x80) /* GF modulo: if a >= 128, then it will overflow when shifted left, so reduce */
			a = (a << 1) ^ 0x11b; /* XOR with the primitive polynomial x^8 + x^4 + x^3 + x + 1 -- you can change it but it must be irreducible */
		else
			a <<= 1; /* equivalent to a*2 */
		b >>= 1; /* equivalent to b // 2 */
	}
	return p;
}



uchar crypto::Low_Level::s_box[256] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7 ,0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

uchar crypto::Low_Level::inverce_s_box[256] =
{
	0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
	0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
	0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
	0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
	0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
	0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
	0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
	0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
	0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
	0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
	0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
	0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
	0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
	0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
	0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};

uchar crypto::Low_Level::rcon[256] = {
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
};


uchar crypto::Low_Level::rijndael[4][4] = {
	{ 0x02, 0x03, 0x01, 0x01 },
	{ 0x01, 0x02, 0x03, 0x01 },
	{ 0x01, 0x01, 0x02, 0x03 },
	{ 0x03, 0x01, 0x01, 0x02 }
};

uchar crypto::Low_Level::inverce_rijndael[4][4] = {
	{ 0x0e, 0x0b, 0x0d, 0x09 },
	{ 0x09, 0x0e, 0x0b, 0x0d },
	{ 0x0d, 0x09, 0x0e, 0x0b },
	{ 0x0b, 0x0d, 0x09, 0x0e }
};